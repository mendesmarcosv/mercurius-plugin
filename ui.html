<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined|Material+Icons+Round" rel="stylesheet">
  <style>
    :root {
      --min-width: 400px;
      --max-width: 800px;
      --primary-color: #404040;
      --primary-hover: #666666;
      --bg-color: #000000;
      --text-color: #FFFFFF;
      --text-secondary: #999999;
      --border-color: #333333;
      --input-bg: #1A1A1A;
      --box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      --result-box-bg: #1A1A1A;
      --hover-bg: #262626;
    }
    
    /* Adicionando estilos do header */
    .header-image {
      position: relative;
      height: 200px;
      margin: 0;
      padding: 24px 0px;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      box-sizing: border-box;
    }

    .header-image img {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100vw;
      height: 200px;
      object-fit: cover;
      object-position: center 40%;
      z-index: 0;
    }

    .header-image::before {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100vw;
      height: 100%;
      background: linear-gradient(to bottom, 
        rgba(0,0,0,0) 0%,
        rgba(0,0,0,0.4) 50%,
        rgba(0,0,0,0.8) 80%,
        rgba(0,0,0,1) 100%
      );
      pointer-events: none;
      z-index: 1;
    }

    .header-image h2 {
      position: relative;
      z-index: 2;
      margin: 0;
      font-size: 32px;
      color: var(--text-color);
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .header-content {
      position: relative;
      z-index: 2;
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
    }

    .api-key-chip {
      background-color: var(--input-bg);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 11px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .api-key-chip:hover {
      background-color: var(--border-color);
    }

    .api-key-chip .material-icons {
      font-size: 14px;
      color: var(--text-color);
      margin-left: auto;
    }

    .header-image p {
      position: relative;
      z-index: 2;
      margin: 8px 0 0 0;
      color: var(--text-secondary);
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    body {
      font-family: 'Poppins', sans-serif;
      padding: 0 40px;
      padding-bottom: 80px;
      background-color: var(--bg-color);
      color: var(--text-color);
      min-width: var(--min-width);
      max-width: var(--max-width);
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
      position: relative;
      overflow-x: hidden;
      padding-right: calc(40px + 8px); /* 40px do padding original + 8px da largura da scrollbar */
      overflow-y: overlay; /* Usa overlay ao invés de auto/scroll */
    }

    /* Estilização da scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--bg-color);
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
      border: 2px solid var(--bg-color);
      position: absolute;
      right: 0;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }
    
    /* Esconder scrollbar no Firefox mas manter funcionalidade */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) var(--bg-color);
    }

    .main-container {
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 24px;
      margin-top: 16px;
      width: 100%;
      box-sizing: border-box;
      position: relative;
    }

    button {
      background-color: var(--text-color);
      color: var(--bg-color);
      border: none;
      padding: 8px 24px;
      border-radius: 100px;
      cursor: pointer;
      width: auto;
      margin: 16px 0 0;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.2s ease;
      box-shadow: var(--box-shadow);
      display: inline-block;
    }

    button#analyze {
      margin: 16px 0 0;
    }

    button:hover {
      background-color: var(--text-color);
      opacity: 0.9;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    .status {
      margin-top: 12px;
      color: var(--text-color);
    }
    .info-line {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 8px 0;
      font-size: 11px;
      color: var(--text-secondary);
    }
    .dimension-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }
    .dimension-item .material-icons-round {
      font-size: 16px;
      color: var(--text-color);
    }
    .dimension-label {
      font-weight: 600;
      color: var(--text-color);
    }
    .dimension-value {
      color: var(--text-secondary);
    }
    #dimensions, #dimensionsExport {
      display: flex;
      gap: 24px;
      margin: 0 0 16px;
      padding: 16px;
      background: var(--input-bg);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      flex-wrap: wrap;
    }
    input[type="text"], input[type="number"] {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background-color: var(--input-bg);
      color: var(--text-color);
      font-size: 12px;
      transition: all 0.2s ease;
    }
    input[type="text"]:focus, input[type="number"]:focus {
      outline: none;
      border-color: var(--text-color);
      box-shadow: none;
    }
    .result-box {
      margin-top: 16px;
      padding: 16px;
      background-color: var(--result-box-bg);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      box-shadow: var(--box-shadow);
    }
    .result-box:first-child {
      margin-top: 0;
    }
    .result-label {
      font-weight: 500;
      color: var(--text-color);
      margin-bottom: 8px;
      font-size: 14px;
    }
    .result-content {
      min-height: 20px;
      word-wrap: break-word;
      color: var(--text-secondary);
      font-size: 12px;
      line-height: 1.5;
    }
    #description {
      margin-bottom: 8px;
    }
    #exportOptions {
      display: none;
      margin-top: 16px;
    }
    .export-label {
      font-weight: 500;
      margin-bottom: 8px;
      color: var(--text-color);
      font-size: 14px;
    }
    .size-buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 4px;
    }
    .size-button {
      background-color: #262626;
      color: var(--text-color);
      border: 1px solid var(--border-color);
      padding: 12px 8px;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      font-size: 12px;
      transition: all 0.2s ease;
      text-transform: none;
      letter-spacing: normal;
      font-weight: normal;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .size-button:hover {
      background-color: #333333;
      border-color: #404040;
    }
    .size-button.selected {
      background-color: var(--text-color);
      border-color: var(--text-color);
    }
    .size-button.selected .scale {
      color: var(--bg-color);
    }
    .size-button.selected .dimensions {
      color: var(--bg-color);
      opacity: 0.7;
    }
    .size-button .scale {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-color);
    }
    .size-button .dimensions {
      font-size: 11px;
      color: var(--text-secondary);
    }
    .filename-container {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }
    .filename-display {
      flex-grow: 1;
      padding: 8px 0px;
      background-color: transparent;
      border-radius: 8px;
      min-height: 20px;
      color: var(--text-secondary);
    }
    .filename-edit {
      display: none;
      width: calc(100% - 32px);
      margin: 4px 0;
      padding: 8px;
      background-color: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
    }
    .edit-icon {
      cursor: pointer;
      padding: 4px 8px;
      color: var(--text-secondary);
      transition: color 0.2s;
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
    }
    .edit-icon:hover {
      color: var(--primary-color);
    }
    .edit-mode .filename-display {
      display: none;
    }
    .edit-mode .filename-edit {
      display: block;
    }
    .edit-mode .edit-icon .material-icons-round {
      content: 'check';
    }
    ::placeholder {
      color: var(--text-secondary);
      opacity: 0.7;
    }

    @media (min-width: 600px) {
      .size-buttons {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (min-width: 800px) {
      .size-buttons {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    @media (max-width: 500px) {
      body {
        padding: 16px;
      }

      .main-container {
        padding: 16px;
      }

      .info-line {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      input[type="number"]#maxSize {
        width: 100%;
        margin-left: 0;
      }
    }

    h2 {
      margin: 0 0 16px 0;
      font-size: 24px;
      font-weight: 600;
      line-height: 1.2;
      color: var(--text-color);
    }

    h2.section-title {
      font-size: 16px;
      margin-bottom: 16px;
    }

    p {
      margin: 0 0 16px 0;
      font-size: 12px;
      font-weight: 400;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    input[type="number"] {
      width: 100%;
      padding: 6px 8px;
      margin: 4px 0;
      border: 1px solid #404040;
      border-radius: 4px;
      background-color: #2D2D2D;
      color: #E0E0E0;
      font-size: 13px;
      -moz-appearance: textfield;
    }
    
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    /* Adicionar estilos do loader e estados de visibilidade */
    .hidden {
      display: none !important;
    }

    .loader {
      width: 24px;
      height: 24px;
      border: 2px solid var(--text-secondary);
      border-bottom-color: transparent;
      border-radius: 50%;
      display: inline-block;
      box-sizing: border-box;
      animation: rotation 1s linear infinite;
      margin: 24px auto;
    }

    @keyframes rotation {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    .loader-container {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
    }

    .analysis-container {
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s ease;
    }

    .analysis-container.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .description-container {
      display: flex;
      align-items: flex-start;
      position: relative;
    }

    .material-icons-round {
      font-size: 20px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .edit-api-key {
      font-size: 18px !important;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .copy-icon {
      cursor: pointer;
      padding: 4px 8px;
      color: var(--text-secondary);
      transition: all 0.2s ease;
      opacity: 0.7;
      display: flex;
      align-items: center;
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
    }

    .copy-icon:hover {
      opacity: 1;
      color: var(--text-color);
    }

    #imageDescription {
      padding-right: 40px;
    }

    .copy-feedback {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--text-color);
      color: var(--bg-color);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 11px;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .copy-feedback.visible {
      opacity: 1;
    }

    .export-status {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--text-color);
      color: var(--bg-color);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 11px;
      opacity: 0;
      transition: opacity 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .export-status .loader {
      width: 12px;
      height: 12px;
      border-width: 1px;
      margin: 0;
    }

    .export-status.visible {
      opacity: 1;
    }

    .floating-button {
      position: fixed;
      right: 24px;
      bottom: 24px;
      margin: 0 !important;
      z-index: 1000;
      padding: 8px 24px !important;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3) !important;
      opacity: 0;
      transform: translateY(16px);
      pointer-events: none;
      transition: all 0.3s ease;
    }

    .floating-button.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }

    .change-key-button {
      position: fixed;
      top: 24px;
      right: 24px;
      background-color: transparent !important;
      color: var(--text-secondary) !important;
      border: 1px solid var(--border-color) !important;
      padding: 8px 16px !important;
      font-size: 11px !important;
      margin: 0 !important;
      opacity: 0.7;
      transition: all 0.2s ease;
    }

    .change-key-button:hover {
      opacity: 1;
      background-color: var(--input-bg) !important;
      transform: translateY(0) !important;
    }

    #analyzeNewImage {
      position: fixed;
      right: 24px;
      bottom: 24px;
      margin: 0;
      z-index: 1000;
      padding: 8px 24px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      display: none;
      opacity: 0;
      transform: translateY(16px);
      transition: all 0.3s ease;
      background-color: var(--text-color);
      color: var(--bg-color);
      border: none;
      border-radius: 100px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #analyzeNewImage.visible {
      display: inline-block;
      opacity: 1;
      transform: translateY(0);
    }

    #exportButton {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }
    #exportButton.enabled {
      opacity: 1;
      cursor: pointer;
      pointer-events: all;
    }

    .screen {
      display: none;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s ease;
    }
    .screen.visible {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }
    #authScreen {
      text-align: center;
      padding: 40px 0;
    }
    #authScreen .main-container {
      max-width: 400px;
      margin: 0 auto;
    }
    #authScreen button {
      margin-top: 24px;
      min-width: 120px;
    }

    .format-buttons {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .format-button {
      background-color: #262626;
      color: var(--text-color);
      border: 1px solid var(--border-color);
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s ease;
      text-transform: none;
      letter-spacing: normal;
      font-weight: normal;
      flex: 1;
      text-align: center;
    }

    .format-button:hover {
      background-color: #333333;
      border-color: #404040;
    }

    .format-button.selected {
      background-color: var(--text-color);
      border-color: var(--text-color);
      color: var(--bg-color);
    }

    .home-buttons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      padding: 0px 0;
    }

    .home-button {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
      padding: 24px !important;
      font-size: 14px !important;
      text-transform: none !important;
      letter-spacing: normal !important;
      background-color: var(--input-bg) !important;
      color: var(--text-color) !important;
      border-radius: 12px !important;
      text-align: center;
      min-height: 160px;
      margin-top: 0px !important
    }

    .home-button:hover {
      background-color: var(--hover-bg) !important;
      transform: translateY(-2px) !important;
    }

    .home-button .material-icons-round {
      font-size: 32px;
      margin-bottom: 4px;
      color: var(--text-secondary);
    }

    .home-button .title {
      font-weight: 600;
      margin-bottom: 2px;
      font-size: 14px;
      text-transform: uppercase;
    }

    .home-button .description {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      line-height: 1.6;
      font-weight: 400;
      text-wrap: balance;
    }

    .back-button {
      position: fixed;
      top: 24px;
      background-color: transparent !important;
      color: var(--text-secondary) !important;
      border: 1px solid var(--border-color) !important;
      padding: 8px !important;
      margin: 0 !important;
      width: 40px !important;
      height: 40px !important;
      display: flex !important;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0.7;
      transition: all 0.2s ease;
    }

    .back-button:hover {
      opacity: 1;
      background-color: var(--input-bg) !important;
      transform: translateY(0) !important;
    }

    .back-button .material-icons-round {
      font-size: 24px;
    }

    #exportButtonSimple {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }
    #exportButtonSimple.enabled {
      opacity: 1;
      cursor: pointer;
      pointer-events: all;
    }

    #selectNewImage {
      position: fixed;
      right: 24px;
      bottom: 24px;
      margin: 0;
      z-index: 1000;
      padding: 8px 24px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      display: none;
      opacity: 0;
      transform: translateY(16px);
      transition: all 0.3s ease;
      background-color: var(--text-color);
      color: var(--bg-color);
      border: none;
      border-radius: 100px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #selectNewImage.visible {
      display: inline-block;
      opacity: 1;
      transform: translateY(0);
    }

  </style>
</head>
<body>
  <div id="homeScreen" class="screen visible">
    <div class="header-image">
      <img src="https://i.ibb.co/Q3LpLsCT/midip-A-single-hyper-realistic-angel-wing-floating-in-a-pitch-b-c2e53d90-3086-453a-97c7-ea641a02ca87.png" alt="Angel wing background">
      <div class="header-content">
        <h2>Mercurius</h2>
      </div>
      <p>Select an image in Figma to analyze or export.</p>
    </div>

    <div class="main-container">
      <div class="home-buttons">
        <button id="goToExport" class="home-button">
          <span class="material-icons-round">file_download</span>
          <span class="title">Export image</span>
          <span class="description">Export your image in multiple formats and sizes with automatic optimization.</span>
        </button>
        <button id="goToAnalyze" class="home-button">
          <span class="material-icons-round">image</span>
          <span class="title">Analyze image</span>
          <span class="description">Get AI-powered analysis of your image with smart file naming suggestions.</span>
        </button>
      </div>
    </div>
  </div>

  <div id="authScreen" class="screen visible">
    <h2>Mercurius</h2>
    <p>Enter your OpenAI API key to start analyzing images.</p>
    
    <div class="main-container">
      <div class="result-box" style="margin-top: 0;">
        <div class="result-label">Authentication</div>
        <input type="text" id="apiKey" placeholder="Enter your OpenAI API key" />
      </div>
      <button id="startAnalyze">Continue</button>
    </div>
  </div>

  <div id="analysisScreen" class="screen">
    <button id="backToHomeAnalysis" class="back-button">
      <span class="material-icons-round">arrow_back</span>
    </button>
    <button id="changeApiKey" class="change-key-button">Change API Key</button>
    <div class="header-image">
      <img src="https://i.ibb.co/Q3LpLsCT/midip-A-single-hyper-realistic-angel-wing-floating-in-a-pitch-b-c2e53d90-3086-453a-97c7-ea641a02ca87.png" alt="Angel wing background">
      <div class="header-content">
        <h2>Mercurius</h2>
        <div class="api-key-chip" onclick="showScreen('authScreen')">
          <span class="key-text">OpenAI API Key: sk-...SBgA</span>
          <span class="material-icons-round edit-api-key">edit</span>
        </div>
      </div>
      <p>Select an image in Figma to analyze and export.</p>
    </div>

    <button id="analyze" style="margin-top: 24px;">Analyze</button>

    <div class="loader-container hidden" id="loaderContainer">
      <div class="loader"></div>
    </div>

    <div class="analysis-container hidden" id="analysisContainer">
      <div class="main-container">
        <h2 class="section-title">Analysis Results</h2>
        <div id="dimensions">
          <div class="dimension-item" id="size">
            <span class="material-icons-round">straighten</span>
            <span><span class="dimension-label">Dimensions:</span> <span class="dimension-value">960x960px</span></span>
          </div>
          <div class="dimension-item" id="ratio">
            <span class="material-icons-round">aspect_ratio</span>
            <span><span class="dimension-label">Aspect Ratio:</span> <span class="dimension-value">1:1</span></span>
          </div>
        </div>
        
        <div id="description" class="result-box">
          <div class="result-label">Image description</div>
          <div class="description-container">
            <div id="imageDescription" class="result-content">
              Image description will appear here...
            </div>
            <div id="copyIcon" class="copy-icon" title="Copy description">
              <span class="material-icons-round">content_copy</span>
            </div>
          </div>
        </div>

        <div id="filename" class="result-box">
          <div class="result-label">File name</div>
          <div class="filename-container">
            <div id="filenameDisplay" class="filename-display result-content">
              Suggested name will appear here...
            </div>
            <input type="text" id="suggestedName" class="filename-edit result-content" />
            <div id="editIcon" class="edit-icon" title="Edit name">
              <span class="material-icons-round">edit</span>
            </div>
          </div>
        </div>
      </div>

      <div class="main-container">
        <h2 class="section-title">Export Settings</h2>
        <div class="result-box" style="margin-top: 0;">
          <div class="result-label">Set maximum file size</div>
          <div class="info-line" style="display: flex; align-items: center; gap: 12px;">
            <label for="maxSize">Maximum size (MB)</label>
            <input type="text" id="maxSize" value="0.2" style="width: 80px;" pattern="[0-9]*[.]?[0-9]+" />
          </div>
        </div>

        <div id="exportOptions" class="result-box">
          <div class="result-label" style="margin-bottom: 4px;">File format</div>
          <div class="format-buttons" id="formatButtons">
            <button class="format-button selected" data-format="webp">WEBP</button>
            <button class="format-button" data-format="png">PNG</button>
            <button class="format-button" data-format="jpg">JPG</button>
          </div>
          <div class="result-label" style="margin-bottom: 4px;">File dimensions</div>
          <div class="size-buttons" id="sizeButtons">
            <!-- Size buttons will be added here dynamically -->
          </div>
          <button id="exportButton" style="width: 100%; margin-top: 16px;">Export image</button>
        </div>
      </div>
    </div>
  </div>

  <button id="analyzeNewImage">Analyze new image</button>

  <div class="copy-feedback hidden" id="copyFeedback">
    Description copied!
  </div>

  <div class="export-status hidden" id="exportStatus">
    <div class="loader"></div>
    <span>Exporting image...</span>
  </div>

  <div id="exportScreen" class="screen">
    <button id="backToHome" class="back-button">
      <span class="material-icons-round">arrow_back</span>
    </button>
    <div class="header-image">
      <img src="https://i.ibb.co/Q3LpLsCT/midip-A-single-hyper-realistic-angel-wing-floating-in-a-pitch-b-c2e53d90-3086-453a-97c7-ea641a02ca87.png" alt="Angel wing background">
      <div class="header-content">
        <h2>Export Image</h2>
      </div>
      <p>Configure your export settings.</p>
    </div>

    <div class="main-container">
      <div id="dimensionsExport">
        <div class="dimension-item" id="selectedFrame">
          <span class="material-icons-round">crop_original</span>
          <span><span class="dimension-label">Selected frame:</span> <span class="dimension-value">Frame name</span></span>
        </div>
        <div class="dimension-item" id="sizeExport">
          <span class="material-icons-round">straighten</span>
          <span><span class="dimension-label">Dimensions:</span> <span class="dimension-value">960x960px</span></span>
        </div>
        <div class="dimension-item" id="ratioExport">
          <span class="material-icons-round">aspect_ratio</span>
          <span><span class="dimension-label">Aspect Ratio:</span> <span class="dimension-value">1:1</span></span>
        </div>
      </div>

      <div class="result-box" style="margin-top: 0;">
        <div class="result-label">Set maximum file size</div>
        <div class="info-line" style="display: flex; align-items: center; gap: 12px;">
          <label for="maxSizeExport">Maximum size (MB)</label>
          <input type="text" id="maxSizeExport" value="0.2" style="width: 80px;" pattern="[0-9]*[.]?[0-9]+" />
        </div>
      </div>

      <div class="result-box">
        <div class="result-label" style="margin-bottom: 4px;">File format</div>
        <div class="format-buttons" id="formatButtonsExport">
          <button class="format-button selected" data-format="webp">WEBP</button>
          <button class="format-button" data-format="png">PNG</button>
          <button class="format-button" data-format="jpg">JPG</button>
        </div>
        <div class="result-label" style="margin-bottom: 4px;">File dimensions</div>
        <div class="size-buttons" id="sizeButtonsExport">
          <!-- Size buttons will be added here dynamically -->
        </div>
        <button id="exportButtonSimple" style="width: 100%; margin-top: 16px;">Export image</button>
      </div>
    </div>
  </div>

  <button id="selectNewImage">Select new image</button>

  <script>
    let currentBlob = null;
    let currentFileName = '';
    let selectedSize = null;
    let selectedFormat = 'webp'; // Formato padrão

    // Configurar input para usar ponto decimal
    const maxSizeInput = document.getElementById('maxSize');
    
    // Forçar o uso do ponto decimal no carregamento inicial
    maxSizeInput.value = "0.2";
    
    // Validar entrada para aceitar apenas números e ponto
    maxSizeInput.addEventListener('input', function(e) {
      let value = this.value;
      
      // Remover qualquer caractere que não seja número ou ponto
      value = value.replace(/[^\d.]/g, '');
      
      // Garantir que só haja um ponto decimal
      const parts = value.split('.');
      if (parts.length > 2) {
        value = parts[0] + '.' + parts.slice(1).join('');
      }
      
      // Atualizar o valor
      this.value = value;
      
      // Validar o valor numérico apenas se houver um valor
      if (value !== '' && value !== '.') {
        const numValue = parseFloat(value);
        if (!isNaN(numValue)) {
          // Se o valor for menor que 0.1, ajustar apenas ao perder o foco
          if (numValue > 10) {
            this.value = "10";
          }
        }
      }
    });

    // Validar o valor mínimo apenas quando o input perder o foco
    maxSizeInput.addEventListener('blur', function() {
      const value = this.value;
      if (value === '' || value === '.') {
        this.value = "0.1";
      } else {
        const numValue = parseFloat(value);
        if (!isNaN(numValue) && numValue < 0.1) {
          this.value = "0.1";
        }
      }
    });

    // Função para trocar de tela
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('visible');
      });
      document.getElementById(screenId).classList.add('visible');
      
      // Se não estiver na tela inicial, garantir que os botões estejam visíveis em suas respectivas telas
      if (screenId === 'analysisScreen') {
        const analyzeNewButton = document.getElementById('analyzeNewImage');
        if (document.getElementById('analysisContainer').classList.contains('visible')) {
          analyzeNewButton.style.display = 'inline-block';
          analyzeNewButton.classList.add('visible');
        }
      } else if (screenId === 'exportScreen') {
        const selectNewButton = document.getElementById('selectNewImage');
        selectNewButton.style.display = 'inline-block';
        selectNewButton.classList.add('visible');
      }
    }

    // Função para truncar a API key
    function truncateApiKey(apiKey) {
      if (!apiKey) return '';
      return `OpenAI API Key: sk-...${apiKey.slice(-4)}`;
    }

    // Funções para gerenciar a API key
    async function saveApiKey(apiKey) {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'save-api-key',
          apiKey: apiKey
        } 
      }, '*');
      const chip = document.querySelector('.api-key-chip');
      chip.style.display = 'flex';
      chip.querySelector('span.key-text').textContent = truncateApiKey(apiKey);
    }

    async function getApiKey() {
      return new Promise((resolve) => {
        parent.postMessage({ 
          pluginMessage: { 
            type: 'get-api-key'
          } 
        }, '*');

        window.addEventListener('message', function handler(event) {
          const msg = event.data.pluginMessage;
          if (msg && msg.type === 'api-key-response') {
            window.removeEventListener('message', handler);
            const chip = document.querySelector('.api-key-chip');
            chip.style.display = msg.apiKey ? 'flex' : 'none';
            if (msg.apiKey) {
              chip.querySelector('span.key-text').textContent = truncateApiKey(msg.apiKey);
            }
            resolve(msg.apiKey);
          }
        });
      });
    }

    // Carregar API key ao iniciar
    document.addEventListener('DOMContentLoaded', async () => {
      // Esconder o chip inicialmente
      document.querySelector('.api-key-chip').style.display = 'none';
      
      // Carregar a API key mas não mudar de tela
      const savedApiKey = await getApiKey();
      if (savedApiKey) {
        document.getElementById('apiKey').value = savedApiKey;
      }

      // Sempre mostrar a tela inicial
      showScreen('homeScreen');
    });

    // Evento do botão continue
    document.getElementById('startAnalyze').onclick = async () => {
      const apiKey = document.getElementById('apiKey').value;
      if (!apiKey) {
        alert('Please enter your OpenAI API key');
        return;
      }
      await saveApiKey(apiKey);
      showScreen('analysisScreen');
    };

    // Função para mostrar/esconder o loader
    function toggleLoader(show) {
      const loader = document.getElementById('loaderContainer');
      loader.classList.toggle('hidden', !show);
      // Forçar um reflow do DOM para garantir que o loader seja exibido imediatamente
      loader.offsetHeight;
    }

    // Função para mostrar os resultados da análise
    function showAnalysisResults() {
      const container = document.getElementById('analysisContainer');
      const analyzeButton = document.getElementById('analyze');
      const analyzeNewButton = document.getElementById('analyzeNewImage');
      
      container.classList.remove('hidden');
      
      // Esconder o botão analyze original
      analyzeButton.style.display = 'none';
      
      // Mostrar o novo botão fixo
      analyzeNewButton.style.display = 'inline-block';
      
      // Pequeno delay para garantir que as transições sejam suaves
      setTimeout(() => {
        container.classList.add('visible');
        analyzeNewButton.classList.add('visible');
      }, 100);
    }

    // Evento do botão analyze inicial
    document.getElementById('analyze').onclick = async () => {
      // Esconder interface e mostrar loader imediatamente
      const analyzeButton = document.getElementById('analyze');
      const analysisContainer = document.getElementById('analysisContainer');
      
      // Primeiro esconder a interface
      analyzeButton.style.display = 'none';
      analysisContainer.classList.remove('visible');
      analysisContainer.classList.add('hidden');
      
      // Depois mostrar o loader
      requestAnimationFrame(() => {
        toggleLoader(true);
      });
      
      const apiKey = await getApiKey();
      if (!apiKey) {
        toggleLoader(false);
        analyzeButton.style.display = 'block';
        alert('Please enter your OpenAI API key');
        return;
      }
      
      // Enviar mensagem para verificar se há uma imagem selecionada
      parent.postMessage({ pluginMessage: { 
        type: 'check-selection',
        apiKey: apiKey
      } }, '*');
    };

    // Evento do botão analyze new image
    document.getElementById('analyzeNewImage').onclick = async () => {
      // Esconder interface e mostrar loader imediatamente
      document.getElementById('analyzeNewImage').classList.remove('visible');
      const analysisContainer = document.getElementById('analysisContainer');
      analysisContainer.classList.remove('visible');
      analysisContainer.classList.add('hidden');
      toggleLoader(true);

      const apiKey = await getApiKey();
      if (!apiKey) {
        toggleLoader(false);
        document.getElementById('analyzeNewImage').classList.add('visible');
        alert('Please enter your OpenAI API key');
        return;
      }
      
      // Enviar mensagem para verificar se há uma imagem selecionada
      parent.postMessage({ pluginMessage: { 
        type: 'check-selection',
        apiKey: apiKey
      } }, '*');
    };

    // Evento do botão change API key
    document.getElementById('changeApiKey').onclick = () => {
      if (confirm('Do you want to change your API key?')) {
        parent.postMessage({ 
          pluginMessage: { 
            type: 'remove-api-key'
          } 
        }, '*');
        document.getElementById('apiKey').value = '';
        document.querySelector('.api-key-chip').style.display = 'none';
        showScreen('authScreen');
      }
    };

    async function resizeImage(base64Image, maxWidth = 800) {
      return new Promise((resolve) => {
        const img = new Image();
        img.src = base64Image;
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ratio = maxWidth / img.width;
          canvas.width = maxWidth;
          canvas.height = img.height * ratio;
          
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          
          resolve(canvas.toDataURL('image/jpeg', 0.7));
        };
      });
    }

    async function analyzeImage(imageBase64, apiKey) {
      try {
        // Resize image before sending
        const resizedImage = await resizeImage(imageBase64);
        const base64Data = resizedImage.split(',')[1];
        
        console.log('Making API request...');
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4-turbo",
            messages: [
              {
                role: "user",
                content: [
                  {
                    type: "text",
                    text: "Answer in exactly two lines:\nFirst line: Short and objective description of the image (maximum 100 characters)\nSecond line: Start with 'Suggested file name:' followed by a descriptive name using only lowercase letters and underscores"
                  },
                  {
                    type: "image_url",
                    image_url: {
                      url: `data:image/jpeg;base64,${base64Data}`
                    }
                  }
                ]
              }
            ],
            max_tokens: 150
          })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(`Erro na API: ${errorData.error?.message || 'Erro desconhecido'}`);
        }

        const data = await response.json();
        
        if (!data.choices || !data.choices[0] || !data.choices[0].message) {
          throw new Error('Resposta da API em formato inválido');
        }

        return data.choices[0].message.content;
      } catch (error) {
        console.error('Erro completo:', error);
        throw new Error(`Erro ao analisar imagem: ${error.message}`);
      }
    }

    async function generateSizes(width, height) {
      // Usar o tamanho original como base (1x)
      const baseWidth = Math.round(width);
      const baseHeight = Math.round(height);

      // Gerar os diferentes tamanhos
      return [
        { scale: '1x', width: baseWidth, height: baseHeight },
        { scale: '2x', width: baseWidth * 2, height: baseHeight * 2 },
        { scale: '3x', width: baseWidth * 3, height: baseHeight * 3 },
        { scale: '5x', width: baseWidth * 5, height: baseHeight * 5 },
      ];
    }

    async function exportSize(size) {
      // Mostrar status de exportação
      const exportStatus = document.getElementById('exportStatus');
      exportStatus.classList.remove('hidden');
      exportStatus.classList.add('visible');

      try {
        if (!currentBlob || !(currentBlob instanceof Blob)) {
          throw new Error('Dados da imagem inválidos');
        }

        // Criar canvas e contexto
        const canvas = document.createElement('canvas');
        canvas.width = size.width;
        canvas.height = size.height;
        const ctx = canvas.getContext('2d');

        // Carregar a imagem diretamente do Blob
        const img = new Image();
        const blobUrl = URL.createObjectURL(currentBlob);

        try {
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = blobUrl;
          });

          // Desenhar no canvas
          ctx.drawImage(img, 0, 0, size.width, size.height);

          // Função para calcular o tamanho do blob em MB
          const getBlobSize = (blob) => blob.size / (1024 * 1024);

          // Função para exportar com qualidade ajustada
          const exportWithQuality = (quality) => {
            return new Promise((resolve) => {
              let mimeType;
              switch (selectedFormat) {
                case 'webp':
                  mimeType = 'image/webp';
                  break;
                case 'png':
                  mimeType = 'image/png';
                  break;
                case 'jpg':
                  mimeType = 'image/jpeg';
                  break;
              }
              canvas.toBlob((blob) => resolve(blob), mimeType, quality);
            });
          };

          // Busca binária para encontrar a melhor qualidade
          const maxSizeMB = parseFloat(document.getElementById('maxSize').value);
          let minQuality = 0.1;
          let maxQuality = 1.0;
          let bestBlob = null;
          let bestQuality = minQuality;

          // Para PNG, não aplicamos compressão com perda
          if (selectedFormat === 'png') {
            bestBlob = await exportWithQuality(1.0);
          } else {
            while (maxQuality - minQuality > 0.01) {
              const currentQuality = (minQuality + maxQuality) / 2;
              const blob = await exportWithQuality(currentQuality);
              const sizeMB = getBlobSize(blob);
              
              if (sizeMB <= maxSizeMB) {
                bestBlob = blob;
                bestQuality = currentQuality;
                minQuality = currentQuality;
              } else {
                maxQuality = currentQuality;
              }
            }
            
            // Se não conseguiu atingir o tamanho desejado, usa a menor qualidade
            if (!bestBlob) {
              bestBlob = await exportWithQuality(0.1);
            }
          }

          // Criar o link de download
          const downloadUrl = URL.createObjectURL(bestBlob);
          const a = document.createElement('a');
          a.href = downloadUrl;
          a.download = `${currentFileName}.${selectedFormat}`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);

          // Limpar as URLs
          URL.revokeObjectURL(downloadUrl);
          URL.revokeObjectURL(blobUrl);

          // Mostrar a qualidade final e tamanho
          const finalSize = getBlobSize(bestBlob).toFixed(2);
          console.log(`Exportado com ${selectedFormat.toUpperCase()}, tamanho: ${finalSize}MB${selectedFormat !== 'png' ? `, qualidade: ${bestQuality.toFixed(2)}` : ''}`);

        } finally {
          // Garantir que a URL do blob seja sempre liberada
          URL.revokeObjectURL(blobUrl);
        }

      } catch (error) {
        console.error('Erro na exportação:', error);
        alert(`Erro ao exportar imagem: ${error.message}`);
      } finally {
        // Esconder status de exportação
        setTimeout(() => {
          exportStatus.classList.remove('visible');
          setTimeout(() => {
            exportStatus.classList.add('hidden');
          }, 200);
        }, 1000);
      }
    }

    function createSizeButtons(sizes, containerId = 'sizeButtons', exportButtonId = 'exportButton') {
      const container = document.getElementById(containerId);
      const exportButton = document.getElementById(exportButtonId);
      
      if (!container || !exportButton) {
        console.error('Container ou botão de exportação não encontrado');
        return;
      }
      
      // Desabilitar o botão de exportação inicialmente
      exportButton.classList.remove('enabled');
      
      container.innerHTML = '';
      selectedSize = null;

      sizes.forEach(size => {
        const button = document.createElement('button');
        button.className = 'size-button';
        
        const scale = document.createElement('span');
        scale.className = 'scale';
        scale.textContent = size.scale;
        
        const dimensions = document.createElement('span');
        dimensions.className = 'dimensions';
        dimensions.textContent = `${size.width}x${size.height}`;
        
        button.appendChild(scale);
        button.appendChild(dimensions);
        
        button.onclick = () => {
          // Remove seleção de todos os botões no mesmo container
          container.querySelectorAll('.size-button').forEach(btn => {
            btn.classList.remove('selected');
          });
          // Adiciona seleção ao botão clicado
          button.classList.add('selected');
          // Armazena o tamanho selecionado
          selectedSize = size;
          // Habilita o botão de exportar
          exportButton.classList.add('enabled');
        };
        
        container.appendChild(button);
      });

      document.getElementById('exportOptions').style.display = 'block';
      
      // Adiciona evento ao botão de exportar
      exportButton.onclick = () => {
        if (!selectedSize) {
          alert('Please select a size before exporting');
          return;
        }
        exportSize(selectedSize);
      };
    }

    onmessage = async (event) => {
      const msg = event.data.pluginMessage;
      
      if (msg.type === 'no-selection') {
        toggleLoader(false);
        // Restaurar o botão apropriado
        const analyzeButton = document.getElementById('analyze');
        const analyzeNewButton = document.getElementById('analyzeNewImage');
        if (analyzeButton.style.display === 'none') {
          analyzeButton.style.display = 'block';
        }
        if (!analyzeNewButton.classList.contains('visible')) {
          analyzeNewButton.classList.add('visible');
        }
        alert('Please select an image in Figma before analyzing.');
        return;
      }
      
      if (msg.type === 'analyze-image') {
        try {
          // Criar o Blob corretamente a partir dos dados binários
          const bytes = new Uint8Array(msg.bytes);
          currentBlob = new Blob([bytes], { type: 'image/png' });
          
          // Verificar se o Blob foi criado corretamente
          if (!currentBlob || currentBlob.size === 0) {
            throw new Error('Falha ao criar o Blob da imagem');
          }

          console.log('Blob criado com sucesso:', {
            size: currentBlob.size,
            type: currentBlob.type
          });

          const sizeValueSpan = document.querySelector('#size .dimension-value');
          const ratioValueSpan = document.querySelector('#ratio .dimension-value');
          const descriptionDiv = document.getElementById('imageDescription');
          const suggestedNameDiv = document.getElementById('suggestedName');
          
          sizeValueSpan.textContent = `${msg.dimensions.width}x${msg.dimensions.height}px`;
          ratioValueSpan.textContent = msg.dimensions.aspectRatio;

          // Criar uma cópia do Blob para a análise
          const analyzeBlob = currentBlob.slice(0, currentBlob.size, currentBlob.type);
          const reader = new FileReader();
          
          reader.onloadend = async () => {
            const base64data = reader.result;
            
            try {
              descriptionDiv.textContent = "Analyzing image...";
              suggestedNameDiv.textContent = "Generating name...";
              
              const response = await analyzeImage(base64data, msg.apiKey);
              
              if (!response) {
                throw new Error('Não foi possível gerar uma descrição para a imagem');
              }

              const parts = response.split('\n');
              const description = parts[0];
              let suggestedName = parts[1] || '';
              
              descriptionDiv.textContent = description;
              
              if (!suggestedName.includes('Suggested file name:')) {
                suggestedName = description;
              }
              
              const aspectRatio = msg.dimensions.aspectRatio.replace(':', 'x');
              
              const baseFileName = suggestedName
                .replace('Suggested file name:', '')
                .trim()
                .toLowerCase()
                .replace(/["']/g, '')
                .replace(/[^a-z0-9]/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_|_$/g, '');

              const finalBaseFileName = baseFileName || 'imagem';
              currentFileName = `${finalBaseFileName}-${aspectRatio}`;
              suggestedNameDiv.value = finalBaseFileName;
              document.getElementById('filenameDisplay').textContent = finalBaseFileName;

              const sizes = await generateSizes(msg.dimensions.width, msg.dimensions.height);
              createSizeButtons(sizes);

              // Esconder loader e mostrar resultados
              toggleLoader(false);
              showAnalysisResults();

            } catch (error) {
              console.error('Detailed error:', error);
              descriptionDiv.textContent = `Error analyzing image: ${error.message}`;
              suggestedNameDiv.textContent = 'Error generating name';
              
              // Esconder loader e mostrar resultados mesmo com erro
              toggleLoader(false);
              showAnalysisResults();
            }
          };

          reader.onerror = (error) => {
            console.error('Error reading image:', error);
            descriptionDiv.textContent = `Error reading image: ${error.message}`;
            suggestedNameDiv.textContent = 'Error reading image';
            
            // Esconder loader e mostrar resultados mesmo com erro
            toggleLoader(false);
            showAnalysisResults();
          };

          reader.readAsDataURL(analyzeBlob);

        } catch (error) {
          console.error('Conversion error:', error);
          descriptionDiv.textContent = `Conversion error: ${error.message}`;
          suggestedNameDiv.textContent = 'Conversion error';
          
          // Esconder loader e mostrar resultados mesmo com erro
          toggleLoader(false);
          showAnalysisResults();
        }
      }
    };

    document.getElementById('copyIcon').onclick = () => {
      const description = document.getElementById('imageDescription').textContent;
      const textArea = document.createElement('textarea');
      textArea.value = description;
      document.body.appendChild(textArea);
      textArea.select();
      
      try {
        document.execCommand('copy');
        const copyFeedback = document.getElementById('copyFeedback');
        copyFeedback.classList.remove('hidden');
        copyFeedback.classList.add('visible');
        setTimeout(() => {
          copyFeedback.classList.remove('visible');
          setTimeout(() => {
            copyFeedback.classList.add('hidden');
          }, 200);
        }, 2000);
      } catch (err) {
        console.error('Erro ao copiar:', err);
      } finally {
        document.body.removeChild(textArea);
      }
    };

    // Função para atualizar o nome do arquivo com a extensão correta
    function updateFilenameWithExtension(name) {
      const displayName = `${name}.${selectedFormat}`;
      filenameDisplay.textContent = displayName;
      currentFileName = name;
    }

    // Adicionar eventos aos botões de formato
    document.querySelectorAll('.format-button').forEach(button => {
      button.onclick = () => {
        // Remove seleção de todos os botões
        document.querySelectorAll('.format-button').forEach(btn => {
          btn.classList.remove('selected');
        });
        // Adiciona seleção ao botão clicado
        button.classList.add('selected');
        // Armazena o formato selecionado
        selectedFormat = button.dataset.format;
        // Atualiza o nome do arquivo com a nova extensão
        updateFilenameWithExtension(currentFileName);
      };
    });

    // Gerenciar edição do nome do arquivo
    const filenameContainer = document.querySelector('.filename-container');
    const filenameDisplay = document.getElementById('filenameDisplay');
    const filenameEdit = document.getElementById('suggestedName');
    const editIcon = document.getElementById('editIcon');
    const editIconSpan = editIcon.querySelector('.material-icons-round');

    editIcon.onclick = () => {
      if (filenameContainer.classList.contains('edit-mode')) {
        // Salvando a edição
        const newName = filenameEdit.value.toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '');
        updateFilenameWithExtension(newName);
        filenameContainer.classList.remove('edit-mode');
        editIconSpan.textContent = 'edit';
      } else {
        // Entrando no modo de edição
        filenameEdit.value = currentFileName;
        filenameContainer.classList.add('edit-mode');
        editIconSpan.textContent = 'check';
        filenameEdit.focus();
      }
    };

    filenameEdit.onkeydown = (e) => {
      if (e.key === 'Enter') {
        editIcon.click(); // Isso irá salvar a edição
      } else if (e.key === 'Escape') {
        filenameContainer.classList.remove('edit-mode');
        editIconSpan.textContent = 'edit';
      }
    };

    // Adicionar eventos para os novos botões
    document.getElementById('goToExport').onclick = async () => {
      const selection = await checkSelection();
      if (!selection) return;
      
      showScreen('exportScreen');
      
      // Atualizar as informações de dimensões
      document.querySelector('#selectedFrame .dimension-value').textContent = selection.name;
      document.querySelector('#sizeExport .dimension-value').textContent = `${selection.width}x${selection.height}px`;
      document.querySelector('#ratioExport .dimension-value').textContent = selection.aspectRatio;
      
      const sizes = await generateSizes(selection.width, selection.height);
      createSizeButtons(sizes, 'sizeButtonsExport', 'exportButtonSimple');
      
      // Mostrar o botão Select new image
      const selectNewButton = document.getElementById('selectNewImage');
      selectNewButton.style.display = 'inline-block';
      setTimeout(() => {
        selectNewButton.classList.add('visible');
      }, 100);
    };

    document.getElementById('goToAnalyze').onclick = async () => {
      const selection = await checkSelection();
      if (!selection) return;

      const apiKey = await getApiKey();
      if (!apiKey) {
        showScreen('authScreen');
      } else {
        showScreen('analysisScreen');
        document.getElementById('analyze').click();
      }
    };

    document.querySelectorAll('.back-button').forEach(button => {
      button.onclick = () => {
        showScreen('homeScreen');
        // Esconder os botões quando voltar para a tela inicial
        document.getElementById('selectNewImage').style.display = 'none';
        document.getElementById('selectNewImage').classList.remove('visible');
        document.getElementById('analyzeNewImage').style.display = 'none';
        document.getElementById('analyzeNewImage').classList.remove('visible');
      };
    });

    // Função para verificar seleção
    async function checkSelection() {
      parent.postMessage({ pluginMessage: { type: 'check-selection-only' } }, '*');
      
      return new Promise((resolve) => {
        window.addEventListener('message', function handler(event) {
          const msg = event.data.pluginMessage;
          if (msg && msg.type === 'selection-check-response') {
            window.removeEventListener('message', handler);
            if (!msg.valid) {
              alert('Please select an image in Figma before proceeding.');
              resolve(null);
            } else {
              resolve(msg.dimensions);
            }
          }
        });
      });
    }

    // Evento do botão select new image
    document.getElementById('selectNewImage').onclick = async () => {
      const selection = await checkSelection();
      if (!selection) return;
      
      // Atualizar as informações de dimensões
      document.querySelector('#selectedFrame .dimension-value').textContent = selection.name;
      document.querySelector('#sizeExport .dimension-value').textContent = `${selection.width}x${selection.height}px`;
      document.querySelector('#ratioExport .dimension-value').textContent = selection.aspectRatio;
      
      const sizes = await generateSizes(selection.width, selection.height);
      createSizeButtons(sizes, 'sizeButtonsExport', 'exportButtonSimple');
    };
  </script>
</body>
</html>